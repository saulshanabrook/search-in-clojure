(ns search.algorithms.base
  (:require [schema.core :as s]
            [com.rpl.specter :as sp]

            [search.schemas :as schemas]
            [search.utils :as utils]))

(def Initial (s/=> s/Str schemas/Generation))
(def Evaluate (s/=> schemas/Generation schemas/Generation))
(def Done (s/=> schemas/Generation s/Bool))
(def Step (s/=> schemas/Generation schemas/Generation))

(s/defn step-until-end :- schemas/Algorithm
  "Basic high level algorithm that will cover most use cases.

  1. Call `initial` with the run ID to get the intial generation.
  2. Call `evaluate` on the current generation, which should return
     a generation whose `:individuals` have updated `traits`
  3. Check current generation is `done?`:
    1. If yes then return the currnent generation
    2. If no, then recur with a new generation, from `step`,
       to step 2."
  [initial :- Initial
   evaluate :- Evaluate
   done? :- Done
   step :- Step]
  (s/fn step-until-end-inner [run-id :- s/Str]
    (utils/take-until
     done?
     (iterate (comp evaluate step) (-> run-id initial evaluate)))))

(s/defn generate-initial :- Initial
  "Returns a function that returns the initial population, by making
   populatin it with `n` genomes, created with `->genome`"
  [->genome :- (s/=> schemas/Genome)
   n :- s/Int]
  (s/fn generate-initial-inner :- schemas/Generation
    [run-id :- s/Str]
    {:index 0
     :run-id run-id
     :individuals (repeatedly n (fn [] {:genome (->genome)
                                        :parents-ids []
                                        :id (utils/id)
                                        :traits {}}))}))

(s/defn evaluate-genome :- Evaluate
  "Returns an evaluate function that generates the traits for each individual
   based on its genome"
  [genome->traits]
  (let [path (sp/comp-paths :individuals sp/ALL (sp/collect-one :genome) :traits)]
    (s/fn evaluate-genome-inner :- schemas/Generation
      [generation :- schemas/Generation]
      (sp/compiled-transform
        path
        (fn [genome _] (genome->traits genome))
        generation))))

(s/defn done?-max-generations :- Done
  "Returns a Done function based on if we are at the maximum number of generations"
  [max :- s/Int]
  (s/fn done?-max-generations-inner :- s/Bool
    [generation :- schemas/Generation]
    (>= (inc (:index generation)) max)))

(s/defn done?-max-trait :- Done
  "Returns a Done function based on if we have reached an acceptable trait value"
  [trait :- s/Keyword
   max_ :- s/Int]
  (s/fn done?-max-trait-inner :- s/Bool
    [generation :- schemas/Generation]
    (<= max_ (apply max (sp/select [:individuals sp/ALL :traits trait] generation)))))

(def Breed (s/=> schemas/Individual [schemas/Individual]))
(s/defn step-breed :- Step
  "Creates a step function, fillin it with `population-size` new individuals
  generated by calling `breed` on the existing ones."
  [population-size :- s/Int
   breed :- Breed]
  (s/fn step-breed-inner :- schemas/Generation
    [generation :- schemas/Generation]
    (->>
      generation
      (sp/transform [:index] inc)
      (sp/transform [:individuals] #(repeatedly population-size (partial breed %))))))

(def Select "Select should return a possible parent from a list of individuals"
  (s/=> schemas/Individual [schemas/Individual]))
(def Tweak
  "Represents a function that is called with some number of parents to return
   a child"
  {:n-parents s/Int :fn (s/=> schemas/Genome)})

(s/defn ->child-individual :- schemas/Individual
  [child-genome :- schemas/Genome
   parents :- [schemas/Individual]]
  {:id (utils/id)
   :genome child-genome
   :parents-ids (map :id parents)
   :traits {}})

(s/defn select-tweak-breed :- Breed
  "Creates a breed function for the common scenario where the new individual
  is created by tweaking two parent genomes."
  [select :- Select
   tweak :- Tweak]
  (s/fn ->breed-inner :- schemas/Individual
    [individuals :- [schemas/Individual]]
    (let [parents (repeatedly (:n-parents tweak) (partial select individuals))]
      (->child-individual (apply (:fn tweak) (map :genome parents)) parents))))
