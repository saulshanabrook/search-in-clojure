(ns search.algorithms.offspring)
; (ns search.offspring
;   (:require [clojure.data.generators]))
;
; (defn weighted-bool [probability-true]
;   "Return a random boolean, True with probability `probability-true`"
;   (clojure.data.generators/weighted {probability-true true (1 - probability-true) false}))
;
; (defn operators->
;   "Applies a weighted map of probabilities to operator functions to the population"
;   ; [operators :- (t/Map t/Num Operator), population :- Population]
;   [operators, population]
;   (let [pop-size (count population)
;         operator (partial clojure.data.generators/weighted operators)]
;     (repeatedly pop-size #((operator) population))))

; (defn vector-mutate [vector new-item mutate-probability]
;   "Returns a new vector of the same length as `vector`, where each item
;   is either the item from the original vector or generated by (new-item) with
;   probality `mutate-probability`"
;   (map
;     (fn [old-item]
;       (let [new-item? (weighted-bool mutate-probability)]
;         (if new-item? (new-item) old-item)))
;     vector))
;
; (defn vector-alternation [vector1 vector2 switch-probability]
;   "Merges two vectors, taking sequential items from one then crossing over and
;   taking items from the other. After each item there is  a `switch-probability`
;   chance of switching to the other vector
;
;   It will stop when it tries to select an index passed the end of either vector"
;   (let [switch? (partial weighted-bool switch-probability)]
;     (loop [index 0
;            vector1? True
;            merged-vector []]
;       (let [current-vector (if vector1? vector1 vector2)]
;         (if (>= index (count current-vector))
;           merged-vector
;           (recur
;             (inc index)
;             (if (switch?) (not vector1?) vector1)
;             (conj merged-vector (nth current-vector index))))))))
